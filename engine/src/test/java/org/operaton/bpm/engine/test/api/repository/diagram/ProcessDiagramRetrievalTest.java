/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information regarding copyright
 * ownership. Camunda licenses this file to you under the Apache License,
 * Version 2.0; you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.operaton.bpm.engine.test.api.repository.diagram;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.RegisterExtension;

import org.operaton.bpm.engine.RepositoryService;
import org.operaton.bpm.engine.impl.bpmn.diagram.ProcessDiagramLayoutFactory;
import org.operaton.bpm.engine.repository.DiagramLayout;
import org.operaton.bpm.engine.repository.DiagramNode;
import org.operaton.bpm.engine.repository.ProcessDefinition;
import org.operaton.bpm.engine.repository.ProcessDefinitionQuery;
import org.operaton.bpm.engine.test.junit5.ParameterizedTestExtension.Parameterized;
import org.operaton.bpm.engine.test.junit5.ParameterizedTestExtension.Parameters;
import org.operaton.bpm.engine.test.junit5.ProcessEngineExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;


/**
 * Tests process model and diagram retrieval features of the
 * {@link RepositoryService}.
 * <p>
 * This test generates HTML code containing the positions and dimensions of all
 * elements in a BPMN process and compares that to HTML files stored in
 * 'src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram'.
 * </p>
 * <p>
 * If the expected HTML code needs to be changed due to changes in
 * {@link ProcessDiagramLayoutFactory}, the files can be regenerated by running the
 * test while {@link ProcessDiagramRetrievalTest#OVERWRITE_EXPECTED_HTML_FILES}
 * is set to true.
 * </p>
 * @author Falko Menge
 */
@Parameterized
public class ProcessDiagramRetrievalTest {

  /**
   * Set this to true and run the tests to regenerate the HTML files located in
   * src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram, which
   * contain expected values for the HTML code generated by test cases.
   */
  private static final boolean OVERWRITE_EXPECTED_HTML_FILES = false;

  @RegisterExtension
  static ProcessEngineExtension engineRule = ProcessEngineExtension.builder().build();

  /**
   * Provides a list of parameters for
   * {@link ProcessDiagramRetrievalTest#ProcessDiagramRetrievalTest(String, String, String, String)}
   */
  @Parameters
  public static Collection<Object[]> data() {
    return List.of(new Object[][] {
            { "testStartEventWithNegativeCoordinates", ".bpmn", ".png", "sid-61D1FC47-8031-4834-A9B4-84158E73F7B9" },
            { "testStartAndEndEventWithNegativeCoordinates", ".bpmn", ".png", "sid-61D1FC47-8031-4834-A9B4-84158E73F7B9" },
            { "testProcessWithTask", ".bpmn", ".png", "sid-1E142B16-AFAF-429E-A441-D1232CFBD560" },
            { "testProcessFromOperatonFoxDesigner", ".bpmn", ".png", "UserTask_1" },
            { "testProcessFromOperatonFoxDesigner", ".bpmn", ".jpg", "UserTask_1" },
            { "testProcessFromActivitiDesigner", ".bpmn20.xml", ".png", "Send_rejection_notification_via_email__3" },
            { "testSequenceFlowOutOfBounds", ".bpmn", ".png", "sid-61D1FC47-8031-4834-A9B4-84158E73F7B9" },
            { "testProcessFromAdonis", ".bpmn", ".png", "_16615" },
            { "testProcessFromIboPrometheus", ".bpmn", ".png", "ibo-5784efbe-35ac-44bc-bcbe-4c18a2f23d5d" },
            { "testProcessFromIboPrometheus", ".bpmn", ".jpg", "ibo-5784efbe-35ac-44bc-bcbe-4c18a2f23d5d" },
            { "testInvoiceProcessOperatonFoxDesigner", ".bpmn20.xml", ".jpg", "Rechnung_freigeben_125" },
            { "testInvoiceProcessSignavio", ".bpmn", ".png", "Freigebenden_zuordnen_143" },
            { "testInvoiceProcessFromBusinessProcessIncubator", ".bpmn", ".png", "Rechnung_kl_ren_148" },
            { "testProcessFromYaoqiang", ".bpmn", ".png", "_3" },
    });
  }

  private final String xmlFileName;
  private final String imageFileName;
  private final String highlightedActivityId;
  private RepositoryService repositoryService;
  private String deploymentId;

  private ProcessDefinitionQuery processDefinitionQuery;

  public ProcessDiagramRetrievalTest(String modelName, String xmlFileExtension, String imageFileExtension, String highlightedActivityId) {
    this.xmlFileName = modelName + xmlFileExtension;
    this.imageFileName = modelName + imageFileExtension;
    this.highlightedActivityId = highlightedActivityId;
  }

  @BeforeEach
  void setup() {
    deploymentId = repositoryService.createDeployment()
      .addClasspathResource("org/operaton/bpm/engine/test/api/repository/diagram/" + xmlFileName)
      .addClasspathResource("org/operaton/bpm/engine/test/api/repository/diagram/" + imageFileName)
      .deploy()
      .getId();
    processDefinitionQuery = repositoryService.createProcessDefinitionQuery();
  }

  @AfterEach
  void teardown() {
    repositoryService.deleteDeployment(deploymentId, true);
  }

  /**
   * Tests {@link RepositoryService#getProcessModel(String)}.
   */
  @TestTemplate
  void testGetProcessModel() throws Exception {
    if (1 == processDefinitionQuery.count()) {
      ProcessDefinition processDefinition = processDefinitionQuery.singleResult();
      InputStream expectedStream = new FileInputStream("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + xmlFileName);
      InputStream actualStream = repositoryService.getProcessModel(processDefinition.getId());
      assertThat(isEqual(expectedStream, actualStream)).isTrue();
    } else {
      // some test diagrams do not contain executable processes
      // and are therefore ignored by the engine
    }
  }

  /**
   * Tests {@link RepositoryService#getProcessDiagram(String)}.
   */
  @TestTemplate
  void testGetProcessDiagram() throws Exception {
    if (1 == processDefinitionQuery.count()) {
      ProcessDefinition processDefinition = processDefinitionQuery.singleResult();
      InputStream expectedStream = new FileInputStream("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + imageFileName);
      InputStream actualStream = repositoryService.getProcessDiagram(processDefinition.getId());
//      writeToFile(repositoryService.getProcessDiagram(processDefinition.getId()),
//              new File("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + imageFileName + ".actual.png"));
      assertThat(isEqual(expectedStream, actualStream)).isTrue();
    } else {
      // some test diagrams do not contain executable processes
      // and are therefore ignored by the engine
    }
  }

  @TestTemplate
  void testGetProcessDiagramAfterCacheWasCleaned() {
    if (1 == processDefinitionQuery.count()) {
      engineRule.getProcessEngineConfiguration().getDeploymentCache().discardProcessDefinitionCache();
      // given
      ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().singleResult();

      // when
      InputStream stream = repositoryService.getProcessDiagram(processDefinition.getId());

      // then
      assertThat(processDefinition.getDiagramResourceName()).isNotNull();
      assertThat(stream).isNotNull();
    } else {
      // some test diagrams do not contain executable processes
      // and are therefore ignored by the engine
    }
  }

  /**
   * Tests {@link RepositoryService#getProcessDiagramLayout(String)} and
   * {@link ProcessDiagramLayoutFactory#getProcessDiagramLayout(InputStream, InputStream)}.
   */
  @TestTemplate
  void testGetProcessDiagramLayout() throws Exception {
    DiagramLayout processDiagramLayout;
    if (1 == processDefinitionQuery.count()) {
      ProcessDefinition processDefinition = processDefinitionQuery.singleResult();
      assertThat(processDefinition).isNotNull();
      processDiagramLayout = repositoryService.getProcessDiagramLayout(processDefinition.getId());
    } else {
      // some test diagrams do not contain executable processes
      // and are therefore ignored by the engine
      final InputStream bpmnXmlStream = new FileInputStream("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + xmlFileName);
      final InputStream imageStream = new FileInputStream("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + imageFileName);

      assertThat(bpmnXmlStream).isNotNull();
      assertThat(imageStream).isNotNull();

      // we need to run this in the ProcessEngine context
      processDiagramLayout = engineRule.getProcessEngineConfiguration()
        .getCommandExecutorTxRequired()
        .execute(commandContext -> new ProcessDiagramLayoutFactory().getProcessDiagramLayout(bpmnXmlStream, imageStream));
    }
    assertLayoutCorrect(processDiagramLayout);
  }

  private void assertLayoutCorrect(DiagramLayout processDiagramLayout) {
    String html = generateHtmlCode(imageFileName, processDiagramLayout, highlightedActivityId);

    File htmlFile = new File("src/test/resources/org/operaton/bpm/engine/test/api/repository/diagram/" + imageFileName + ".html");
    try {
      if (OVERWRITE_EXPECTED_HTML_FILES) {
        FileUtils.writeStringToFile(htmlFile, html, StandardCharsets.UTF_8);
        fail("The assertions of this test only work if ProcessDiagramRetrievalTest#OVERWRITE_EXPECTED_HTML_FILES is set to false.");
      }
      assertThat(html).isEqualTo(FileUtils.readFileToString(htmlFile, StandardCharsets.UTF_8).replace("\r", "")); // remove carriage returns in case the files have been fetched via Git on Windows
    } catch (IOException e) {
      fail("Could not read or write file: " + e.getMessage());
    }
  }

  private static String generateHtmlCode(String imageUrl, DiagramLayout processDiagramLayout, String highlightedActivityId) {
    StringBuilder html = new  StringBuilder();
    html.append("<!DOCTYPE html>\n");
    html.append("<html>\n");
    html.append("  <head>\n");
    html.append("    <style type=\"text/css\"><!--\n");
    html.append("      .BPMNElement {\n");
    html.append("        position: absolute;\n");
    html.append("        border: 2px dashed lightBlue;\n");
    html.append("        border-radius: 5px; -moz-border-radius: 5px;\n");
    html.append("      }\n");
    if (highlightedActivityId != null && !highlightedActivityId.isEmpty()) {
      html.append("      #").append(highlightedActivityId).append(" {border: 2px solid red;}\n");
    }
    html.append("    --></style>");
    html.append("  </head>\n");
    html.append("  <body>\n");
    html.append("    <div style=\"position: relative\">\n");
    html.append("      <img src=\"").append(imageUrl).append("\" />\n");

    List<DiagramNode> nodes = new ArrayList<>(processDiagramLayout.getNodes());
    // sort the nodes according to their ID property.
    nodes.sort(new DiagramNodeComparator());
    for (DiagramNode node : nodes) {
      html.append("      <div");
      html.append(" class=\"BPMNElement\"");
      html.append(" id=\"").append(node.getId()).append("\"");
      html.append(" style=\"");
      html.append(" left: " + (int) (node.getX() - 2) + "px;");
      html.append(" top: " + (int) (node.getY() - 2) + "px;");
      html.append(" width: ").append(node.getWidth().intValue()).append("px;");
      html.append(" height: ").append(node.getHeight().intValue()).append("px;\"></div>\n");
    }
    html.append("    </div>\n");
    html.append("  </body>\n");
    html.append("</html>");
    return html.toString();
  }

  private static boolean isEqual(InputStream stream1, InputStream stream2)
          throws IOException {

      ReadableByteChannel channel1 = Channels.newChannel(stream1);
      ReadableByteChannel channel2 = Channels.newChannel(stream2);

      ByteBuffer buffer1 = ByteBuffer.allocateDirect(1024);
      ByteBuffer buffer2 = ByteBuffer.allocateDirect(1024);

      try {
          while (true) {

              int bytesReadFromStream1 = channel1.read(buffer1);
              int bytesReadFromStream2 = channel2.read(buffer2);

            if (bytesReadFromStream1 == -1 || bytesReadFromStream2 == -1) {
              return bytesReadFromStream1 == bytesReadFromStream2;
            }

              buffer1.flip();
              buffer2.flip();

            for (int i = 0;i < Math.min(bytesReadFromStream1, bytesReadFromStream2);i++) {
              if (buffer1.get() != buffer2.get()) {
                return false;
              }
            }

              buffer1.compact();
              buffer2.compact();
          }

      } finally {
        if (stream1 != null) {
          stream1.close();
        }
        if (stream2 != null) {
          stream2.close();
        }
      }
  }

  /**
   * sorts {@link DiagramNode DiagramNodes} by ID
   */
  public static class DiagramNodeComparator implements Comparator<DiagramNode> {

    @Override
    public int compare(DiagramNode o1, DiagramNode o2) {
      if(o1.getId() == null)  {
        return 0;
      }
      return o1.getId().compareTo(o2.getId());
    }

  }

}
