name: Auto-Merge Eligible PRs

on:
  schedule:
    # Run at 4:00 AM UTC daily
    - cron: '0 4 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    name: Auto-merge eligible PRs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Collect and merge eligible PRs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Load configuration from YAML file
            // Since js-yaml is not available in github-script,
            // we use Python to convert YAML to JSON
            // Note: This reads from our own repository file, not user input
            const configPath = '.github/auto-merge.config.yml';
            const yamlContent = fs.readFileSync(configPath, 'utf8');
            const jsonStr = execSync(
              `python3 -c "import yaml, json, sys; print(json.dumps(yaml.safe_load(sys.stdin.read())))"`,
              { input: yamlContent, encoding: 'utf8' }
            );
            const config = JSON.parse(jsonStr);

            console.log('üìã Loaded auto-merge configuration');
            console.log(`Found ${config['auto-merge-rules'].length} rule(s)`);

            // Get all open pull requests
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            console.log(`\nüîç Found ${pullRequests.length} open PR(s)`);

            // Function to check if title matches pattern
            function titleMatchesPattern(title, pattern) {
              if (pattern === '*') return true;

              // Convert wildcard pattern to regex for substring matching
              // Escape special regex characters except *
              const regexPattern = pattern
                .replace(/[.+?^${}()|[\]\\]/g, '\\$&')
                .replace(/\*/g, '.*');
              const regex = new RegExp(regexPattern);

              return regex.test(title);
            }

            // Function to check if PR matches any rule
            function matchesRule(pr, rule) {
              // Check author
              if (pr.user.login !== rule.author) {
                return false;
              }

              // If rule has a title pattern, check if PR title matches
              if (rule.title) {
                const titleMatches = titleMatchesPattern(pr.title, rule.title);
                if (titleMatches) {
                  console.log(`  ‚úÖ Title "${pr.title}" matches pattern "${rule.title}" in rule`);
                  return true;
                }
                return false;
              }

              // Otherwise, check labels and includes (legacy behavior for dependency PRs)
              // Check labels - all required labels must be present
              if (!rule.labels || !rule.includes) {
                console.log(
                  `  ‚ö†Ô∏è  Invalid rule: at least one matching criterion is required (either 'title' or both 'labels' and 'includes'). ` +
                  `Rules without these (e.g. only 'author') are rejected to avoid overly permissive auto-merging.`
                );
                return false;
              }

              const prLabels = pr.labels.map(l => l.name);
              const hasAllLabels = rule.labels.every(label => prLabels.includes(label));
              if (!hasAllLabels) {
                return false;
              }

              // Check if title matches any include pattern
              const matches = rule.includes.some(pattern => titleMatchesPattern(pr.title, pattern));

              if (matches) {
                console.log(`  ‚úÖ Title "${pr.title}" matches pattern in rule`);
              }

              return matches;
            }

            // Function to check if all checks have passed
            async function allChecksPassed(pr) {
              try {
                // Get the latest commit SHA
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number
                });

                if (commits.length === 0) {
                  return false;
                }

                const latestCommit = commits[commits.length - 1];
                const sha = latestCommit.sha;

                // Get combined status for the commit
                const { data: status } = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                // Get check runs for the commit
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                // Check combined status and check runs
                // status.total_count = 0 means no status checks configured
                // status.state can be 'success', 'pending', 'failure', 'error', or ''
                const hasStatusChecks = status.total_count > 0;
                const hasCheckRuns = checkRuns.check_runs.length > 0;

                // If there are status checks, verify they passed
                if (hasStatusChecks && status.state !== 'success') {
                  if (status.state === 'pending') {
                    console.log(`  ‚è≥ Status checks are still pending`);
                  } else {
                    console.log(`  ‚ùå Status checks failed or are in error state: ${status.state}`);
                  }
                  return false;
                }

                // Check if any check run failed or is pending
                const failedOrPendingChecks = checkRuns.check_runs.filter(
                  run => run.status !== 'completed' || run.conclusion !== 'success' && run.conclusion !== 'skipped'
                );

                if (failedOrPendingChecks.length > 0) {
                  const pendingChecks = failedOrPendingChecks.filter(run => run.status !== 'completed');
                  const failedChecks = failedOrPendingChecks.filter(
                    run => run.status === 'completed' && run.conclusion !== 'success' && run.conclusion !== 'skipped'
                  );

                  if (pendingChecks.length > 0) {
                    console.log(`  ‚è≥ ${pendingChecks.length} check(s) still pending`);
                  }
                  if (failedChecks.length > 0) {
                    console.log(`  ‚ùå ${failedChecks.length} check(s) failed`);
                  }
                  return false;
                }

                // Ensure at least one type of check exists
                if (!hasStatusChecks && !hasCheckRuns) {
                  console.log(`  ‚ö†Ô∏è  No status checks or check runs found - skipping for safety`);
                  return false;
                }

                console.log(`  ‚úÖ All checks passed`);
                return true;
              } catch (error) {
                console.log(`  ‚ö†Ô∏è  Error checking status: ${error.message}`);
                return false;
              }
            }

            // Collect eligible PRs
            const eligiblePRs = [];

            for (const pr of pullRequests) {
              console.log(`\nüìù Checking PR #${pr.number}: ${pr.title}`);
              console.log(`   Author: ${pr.user.login}`);
              console.log(`   Labels: ${pr.labels.map(l => l.name).join(', ') || 'none'}`);

              // Check if PR matches any rule
              let matchedRule = null;
              for (const rule of config['auto-merge-rules']) {
                if (matchesRule(pr, rule)) {
                  matchedRule = rule;
                  break;
                }
              }

              if (!matchedRule) {
                console.log(`  ‚è≠Ô∏è  Does not match any auto-merge rule`);
                continue;
              }

              // Check if PR has merge conflicts
              // Only 'clean' state means no conflicts and ready to merge
              // 'dirty' = has conflicts, 'unknown' = GitHub is still calculating
              // Other states like 'blocked' are handled by the checks validation
              if (pr.mergeable_state === 'dirty') {
                console.log(`  ‚ö†Ô∏è  PR has merge conflicts - requesting recreate`);
                
                // Check if we already commented about recreate
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number
                });
                
                // Check for exact match of recreate comment from this workflow
                const recreateCommentBody = '@dependabot recreate';
                const hasRecreateComment = comments.some(
                  comment => comment.user.login === 'github-actions[bot]' && 
                             comment.body.trim() === recreateCommentBody
                );
                
                if (!hasRecreateComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: recreateCommentBody
                  });
                  console.log(`  üí¨ Requested recreate from dependabot`);
                } else {
                  console.log(`  ‚ÑπÔ∏è  Recreate already requested`);
                }
                
                continue;
              }
              
              // Skip PRs where GitHub is still calculating merge status
              if (pr.mergeable_state === 'unknown') {
                console.log(`  ‚è≥ Merge status unknown - will check on next run`);
                continue;
              }

              // Check if all checks have passed
              const checksPassed = await allChecksPassed(pr);

              if (checksPassed) {
                console.log(`  ‚ú® PR is eligible for auto-merge`);
                eligiblePRs.push(pr);
              }
            }

            console.log(`\n\nüéØ Summary: ${eligiblePRs.length} PR(s) eligible for auto-merge`);

            // Approve and merge eligible PRs
            for (const pr of eligiblePRs) {
              console.log(`\nüöÄ Processing PR #${pr.number}: ${pr.title}`);

              try {
                // Skip approval for PRs from github-actions[bot] since it cannot approve its own PRs
                if (pr.user.login !== 'github-actions[bot]') {
                  // Check if already approved by this workflow
                  const { data: reviews } = await github.rest.pulls.listReviews({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number
                  });

                  const alreadyApproved = reviews.some(
                    review => review.user.login === 'github-actions[bot]' && review.state === 'APPROVED'
                  );

                  if (!alreadyApproved) {
                    // Approve the PR
                    await github.rest.pulls.createReview({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      event: 'APPROVE',
                      body: '‚úÖ Auto-approved by auto-merge workflow - all checks passed and PR meets the auto-merge criteria.'
                    });
                    console.log(`  ‚úÖ Approved PR #${pr.number}`);
                  } else {
                    console.log(`  ‚ÑπÔ∏è  PR #${pr.number} already approved`);
                  }
                } else {
                  console.log(`  ‚è≠Ô∏è  Skipping approval for PR from ${pr.user.login} (cannot approve own PR)`);
                }

                // Merge the PR using squash
                // Truncate PR body to avoid excessively long commit messages
                const prBody = pr.body || '';
                const truncatedBody = prBody.length > 500
                  ? prBody.substring(0, 500) + '...\n\n(truncated)'
                  : prBody;

                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: pr.title,
                  commit_message: `Auto-merged by auto-merge workflow\n\n${truncatedBody}`
                });

                console.log(`  ‚úÖ Successfully merged PR #${pr.number} using squash`);

              } catch (error) {
                console.log(`  ‚ùå Error processing PR #${pr.number}: ${error.message}`);
              }
            }

            console.log(`\n‚ú® Auto-merge workflow completed`);
